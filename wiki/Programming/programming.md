---
title: Programming
description: Programming is hard.
---

Programming is hard[1] and the current state of software engineering kind of sucks and probably won't get better[3].

But that being said, there is a lot of joy in programming and {{problem solving}}.

> I have a well-deserved reputation for being something of a gadget freak, and am rarely happier than when spending an entire day programming my computer to perform automatically a task that would otherwise take me a good ten seconds to do by hand. Ten seconds, I tell myself, is ten seconds. Time is valuable, and ten seconds’ worth of it is well worth the investment of a happy day’s activity working out a way of saving it. -- Douglas Adams[5]

> From a purely business perspective, this project probably cost the company money. The programming, which was in a part of the system I had never looked at before, took something like a full day of my time including the code changes, testing, and deployment. [...T]he cost-benefit break-even point was at least several months out, possibly many years[.]
>
> But the moral calculus was in everyone's favor.  What is money, after all, compared with good and evil?  If [...] the only cost was a few hours of my time, that was time and money well-spent making the world a better place. -- Mark Dominus[4]

While often programming is about "efficiency" or "productivity", if I ever forget the joy of reveling in a mundane or silly problem, twisting and flipping it to find a novel or interesting or satisfying solution, the rush of seeing your Rube Goldberg Mouse Trap-esque jalopy fire out the desired result, please pull me out of that hell at all costs.

## The Seven Ur-languages[2]

From [madhadron](https://madhadron.com/posts/seven_languages.html):

> [N]ot all languages have the same set of patterns. The patterns for looping in C or Python are very different from the patterns of recursion in Standard ML or Prolog. The way you organize a program in Lisp, where you name new language constructs, is very different from how you organize it in APL, where fragments of symbol sequences are both the definitions of behavior and become the label for that behavior in your  mind.
>
> These distinct collections of fundamentals form various *ur*-languages. Learning a new language that traces to the same *ur*-language is an easy shift. Learning one that traces to an unfamiliar *ur*-language requires significant time and effort and new neural pathways.

- ALGOL
- Lisp
- ML
- Self
- Forth
- APL
- Prolog

## References

1. https://web.eecs.utk.edu/~azh/blog/thisprojectwillonlytake.html
1. https://madhadron.com/posts/seven_languages.html
1. https://tonsky.me/blog/disenchantment/
1. https://blog.plover.com/tech/olafs-report.html
1. https://brianhreily.wordpress.com/2015/12/04/recreating-adams-megapode-modeler/
1. https://www.geepawhill.org/2018/04/14/tdd-the-lump-of-coding-fallacy/